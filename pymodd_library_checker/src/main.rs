//! find and log new actions and functions missing in pymodd

include!("../../src/project_generator/utils/to_pymodd_maps.rs");

use std::fs::File;
use std::io::Write;

use crossterm::style::Stylize;
use pymodd_library_checker::{
    geneerate_function_class_from_object, generate_action_function_from_object,
    get_modd_io_editor_data, Object, ObjectType,
};
use serde_json::Value;

const EXCLUDED_ACTIONS: [&str; 2] = [
    // these actions do not work in modd.io as of (3/20/2023)
    "addUnitToUnitGroup",
    "addPlayerToPlayerGroup",
];

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("\nValidating pymodd library...");

    let editor_data = get_modd_io_editor_data()?;
    let modd_objects_data: &Vec<Value> = editor_data
        .get("message")
        .unwrap_or(&Value::Null)
        .as_array()
        .expect("invalid data: missing message content");

    let (mut missing_actions, mut missing_functions) = (Vec::new(), Vec::new());
    // find missing actions
    modd_objects_data.iter().for_each(|object_data| {
        if ObjectType::from_object_data(object_data) == ObjectType::Action {
            let action_object = Object::from_object_data(object_data);
            if ACTIONS_TO_PYMODD_STRUCTURE.get(&action_object.name) == None {
                missing_actions.push(action_object);
            }
        }
    });

    // find missing functions
    modd_objects_data.iter().for_each(|object_data| {
        if ObjectType::from_object_data(object_data) == ObjectType::Function {
            let function_object = Object::from_object_data(object_data);
            if FUNCTIONS_TO_PYMODD_STRUCTURE.get(&function_object.name) == None {
                missing_functions.push(function_object);
            }
        }
    });

    // remove excluded actions from missing actions
    missing_actions = missing_actions
        .into_iter()
        .filter(|action| !EXCLUDED_ACTIONS.contains(&action.name.as_str()))
        .collect();

    // log number of missing actions
    println!(
        "  missing actions: {}",
        if missing_actions.is_empty() {
            String::from("0").dark_green()
        } else {
            missing_actions.len().to_string().red()
        }
    );
    if !missing_actions.is_empty() {
        // generate missing action functions content in a file
        println!(
            "    {} generating {} content",
            "-".dark_green(),
            "new_actions.py".dark_cyan()
        );
        write!(
            File::create("new_actions.py")?,
            "# generated by the pymodd_library_validator\n\n\n{}",
            missing_actions
                .iter()
                .map(|action_object| {
                    format!(
                        "{}\n\n\n",
                        generate_action_function_from_object(action_object)
                    )
                })
                .collect::<String>()
                .trim_end()
        )?;
    }

    // log number of missing functions
    println!(
        "  missing functions: {}",
        if missing_functions.is_empty() {
            String::from("0").dark_green()
        } else {
            missing_functions.len().to_string().red()
        }
    );
    if !missing_functions.is_empty() {
        // generate missing function classes content in a file
        println!(
            "    {} generating {} content",
            "-".dark_green(),
            "new_functions.py".dark_cyan()
        );
        write!(
            File::create("new_functions.py")?,
            "# generated by the pymodd_library_validator\n\n\n{}",
            missing_functions
                .iter()
                .map(|function_object| {
                    format!(
                        "{}\n\n\n",
                        geneerate_function_class_from_object(function_object)
                    )
                })
                .collect::<String>()
                .trim_end()
        )?;
    }

    println!("\nvalidation {}\n", "compelete".dark_green());
    Ok(())
}
